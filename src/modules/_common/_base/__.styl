// Vars

// from 0 to 767px
$_b__mobile = 'screen and (max-width: 767px)'
$_b__mobile_portrait = 'screen and (max-width: 480px)'

// from 0 to 1024px
$_b__tablet = 'screen and (max-width: 1024px)'

// from 1025px + infinity
$_b__desktop = 'screen and (min-width: 1025px)'

// retina devices
$_b__retina = '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)'
$_b__non-retina = 'not screen and (-webkit-min-device-pixel-ratio: 2), not screen and (min--moz-device-pixel-ratio: 2), not screen and (-o-min-device-pixel-ratio: 2/1), not screen and (min-device-pixel-ratio: 2), not screen and (min-resolution: 192dpi), not screen and (min-resolution: 2dppx)'

$_b__canvas-width = 1170px
$_b__gap-unit = 30px

// Числовое значение для слова "дофига"
$ultra-width = 20000px
$ultra-length = $ultra-width

// Mixins
_media($screen)
  for $num in arguments
    $media $num
      {block}

//**
//* Адаптивная высота блока на основе его текущей ширины и переданного соотношения сторон
//* Внимание! Блок обязательно должен иметь box-sizing: content-box
//* @param {number} ratio Соотношение сторон "ширина/высота"
//* @uses height
//* @uses padding-bottom
//* @see https://css-tricks.com/scaled-proportional-blocks-with-css-and-javascript/
//*/
_adaptive-height($x, $y)
  $padding = unit(($y / $x) * 100, '%')

  height: 0
  box-sizing: content-box
  padding-bottom: $padding

// CSS-треугольники на основе свойства border
_triangle($color, $direction, $size = 6px)
  width: 0
  height: 0

  if $direction == down
    border-left: $size solid transparent
    border-right: $size solid transparent
    border-top: $size solid $color

  if $direction == up
    border-left: $size solid transparent
    border-right: $size solid transparent
    border-bottom: $size solid $color

  if $direction == right
    border-top: $size solid transparent
    border-bottom: $size solid transparent
    border-left: $size solid $color

  if $direction == left
    border-top: $size solid transparent
    border-bottom: $size solid transparent
    border-right: $size solid $color

_text-overflow-ellipsis-auto($line-count, $line-height = $line-height, $height-prop = height)
  if $line-count == 1
    {$height-prop}: $line-height
    text-overflow-ellipsis()
  else if $line-count > 1
    {$height-prop}: $line-height * $line-count
    text-overflow-ellipsis-multiline($line-count)

_text-overflow-ellipsis()
  overflow: hidden
  white-space: nowrap
  text-overflow: ellipsis

_text-overflow-ellipsis-multiline($line-count)
  display: block
  display: -webkit-box
  overflow: hidden
  -webkit-line-clamp: $line-count
  -webkit-box-orient: vertical
  text-overflow: ellipsis
  text-overflow: -o-ellipsis-lastline

// Opera 10.6 - 12.x

/**
 * Равномерное распределение вложенных инлайн-блоков, включая последнюю строку
 * $uses ::after
 * $uses line-height
 */
_justify-children()
  text-align: justify
  font-size: 0
  line-height: 0
  text-justify: newspaper // fallback для ie

  &::after
    content: ''
    display: inline-block
    width: 100%
    vertical-align: top


/**
 * Задание position и свойств top, right, bottom, left
 * Можно задавать от 1 до 4 значений (в порядке "как у паддинга")
 * Чтобы не задавать какое-либо из значений, нужно использовать значение null
 * $mixin
 * $example position(absolute, 5px, 10px, 0, auto)
 * $example position(absolute, 5px, null, 0, auto)
 * $example position(fixed, 5px, 10px)
 * $example position(fixed, 0)
 */
position()
  $arglen = length(arguments)
  if $arglen >= 1
      position: arguments[0]

  $sides = $arglen - 1
  if $sides == 1
    $top = $right = $bottom = $left = arguments[1]
  else if $sides == 2
    $top = $bottom = arguments[1]
    $right = $left = arguments[2]
  else if $sides == 3
    $top = arguments[1]
    $right = $left = arguments[2]
    $bottom = arguments[3]
  else if $sides >= 4
    $top = arguments[1]
    $right = arguments[2]
    $bottom = arguments[3]
    $left = arguments[4]

  if $left is a 'unit' or $left == 'auto'
    left: $left
  if $right is a 'unit' or $right == 'auto'
    right: $right
  if $top is a 'unit' or $top == 'auto'
    top: $top
  if $bottom is a 'unit' or $bottom == 'auto'
    bottom: $bottom

/**
 * Задание position: absolute и свойств top, right, bottom, left
 * Можно задавать от 1 до 4 значений (в порядке "как у паддинга")
 * Чтобы не задавать какое-либо из значений, нужно использовать значение null
 * $mixin
 * $example absolute(5px, 10px, 0, auto)
 * $example absolute(5px, null, 0, auto)
 * $example absolute(5px, 10px)
 * $example absolute(0)
 */
absolute()
  unshift(arguments, absolute)
  position(arguments)

/**
 * $mixin Задание position: fixed и свойств top, right, bottom, left
 * $see absolute()
 */
fixed()
  unshift(arguments, fixed)
  position(arguments)

/**
 * $mixin Задание position: relative и свойств top, right, bottom, left
 * $see absolute()
 */
relative()
  unshift(arguments, relative)
  position(arguments)

// Делает блок "бесконечной ширины"
_full-width($extra-padding-x = 0)
  margin-left: -$ultra-width
  margin-right: -$ultra-width
  padding-left: $ultra-width + $extra-padding-x
  padding-right: $ultra-width + $extra-padding-x

//**
//* Устанавливает подчёркивание для ссылок (сплошное или пунктирное)
//* $param {color} static-color Цвет ссылки и подчёркивания
//* $param {color} [hover-color=$c_red] Цвет ссылки и подчёркивания при наведении
//* $param {keyword} [type=solid] Тип подчёркивания (solid|dashed|dynamic)
//* $param {length} [dash-width=2px] Ширина пунктира
//* $param {length} [gap-width=2px] Ширина пробела между пунктирами
//* $param {length} [$pos-y=1.1em] На каком уровне распологать подчёркивание
//* РЕКОМЕНДУЕТСЯ ПРИМЕНЯТЬ МИКСИН ТОЛЬКО К ЭЛЕМЕНТАМ С DISPLAY: INLINE
//* в других случаях придётся самому менять положение подчёркивания, что очень геморно
//*/
//_link-underline($static-color, $hover-color = $_c__red, $type = solid, $dash-width = 2px, $gap-width = 2px, $pos-y = 100%) {
//  $unit-width = $dash-width + $gap-width
//  $ratio =  percentage($dash-width / $unit-width)
//  $opacity = 0.3
//
//  &
//    color: $static-color
//    background-repeat: repeat-x
//    background-position: 0 $pos-y // располагаем подчёркивание примерно на уровне text-decoration
//    background-size: $unit-width 1px
//
//    &:hover
//      color: $hover-color
//
//  // Случай, когда сплошное подчёркивание
//  if $type == solid
//    background-image: linear-gradient(to right, rgba($static-color, $opacity) 50%, rgba($static-color, $opacity) 100%)
//
//    &:hover
//      background-image: linear-gradient(to right, rgba($hover-color, $opacity) 50%, rgba($static-color, $opacity) 100%)
//
//  // Случай, когда пунктирное подчёркивание
//  if $type == dashed
//    background-image: linear-gradient(to right, rgba($static-color, $opacity) $ratio, rgba($static-color, 0%) 0%)
//
//    &:hover
//      background-image: linear-gradient(to right, rgba($hover-color, $opacity) $ratio, rgba($hover-color, 0%) 0%)
//
//  // Случай, когда в обычном состоянии нет подчеркивания, а есть при наведении
//  if $type == dynamic
//    background-image: none
//
//    &:hover
//      background-image: linear-gradient(to right, rgba($static-color, 1) 50%, rgba($static-color, 1) 100%)
//
//**
//* В Android Chrome не работает свойство -webkit‑text‑size‑adjust, поэтому вот так неоднозначный костыль
//* @use max-height
//* @see http://stackoverflow.com/a/15137584/3027390
//*/
//_prevent-text-size-adjust()
//  max-height: 20000px

//**
//* Подсчёт ширины для блока с дочереними элементами фиксированной ширины
//* @param {number} item-width - ширина дочерних элементов
//* @param {number} items-count - количество дочерних элементов
//* @param {string} item-offset-x - отступы между дочерними элементами
//*/
//_container-width($item-width, $items-count, $item-offset-x = 0)
//  $item-offset-x-count = $items-count - 1
//
//  width: ($item-width * $items-count) + ($item-offset-x * $item-offset-x-count)
//
//
















